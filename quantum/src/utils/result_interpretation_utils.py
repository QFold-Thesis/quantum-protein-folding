"""
Module providing tools to interpret and handle protein folding results, including
XYZ file creation and JSON sanitization.
"""

from __future__ import annotations

import dataclasses
import json
from collections.abc import Mapping, Sequence
from pathlib import Path
from typing import Any

import numpy as np

from constants import (
    XYZ_FILE_LINE_START_INDEX,
    XYZ_FILE_PARTS_PER_LINE,
    XYZ_FILENAME,
)
from logger import get_logger
from result.models import BeadPosition

logger = get_logger()


def create_xyz_file(coords: list[BeadPosition], dirpath: Path) -> None:
    """
    Create an .xyz file from the given bead positions.

    Note:
        XYZ file format reference: https://en.wikipedia.org/wiki/XYZ_file_format
        Since no formal standard exists, this implementation follows the most common convention.

    Args:
        coords (list[BeadPosition]): List of bead positions to include in the XYZ file.
        dirpath (Path): Directory path where the XYZ file will be created.

    Raises:
        Exception: If there is an error creating the XYZ file.

    """
    filepath: Path = dirpath / XYZ_FILENAME

    try:
        with filepath.open("w") as f:
            f.write(f"{len(coords)}\n")
            f.write("Generated by QFold-Thesis/quantum-protein-folding\n")

            for bead_pos in coords:
                f.write(
                    f"{bead_pos.symbol:<2} {bead_pos.x:>10.4f} {bead_pos.y:>10.4f} {bead_pos.z:>10.4f}\n"
                )
    except Exception:
        logger.exception("Error creating XYZ file")
        raise
    else:
        logger.info(f"XYZ file created at {filepath}")


def read_xyz_file(filepath: Path) -> list[BeadPosition]:
    """
    Read bead positions from an .xyz file.

    Note:
        XYZ file format reference: https://en.wikipedia.org/wiki/XYZ_file_format
        Since no formal standard exists, this implementation follows the most common convention.

    Args:
        filepath (Path): Path to the XYZ file.

    Returns:
        list[BeadPosition]: List of bead positions read from the file.

    Raises:
        Exception: If there is an error reading the XYZ file.

    """
    coords: list[BeadPosition] = []

    try:
        with filepath.open() as f:
            lines = f.readlines()
            num_atoms = int(lines[0].strip())

            for index, line in enumerate(
                lines[XYZ_FILE_LINE_START_INDEX : XYZ_FILE_LINE_START_INDEX + num_atoms]
            ):
                parts = line.split()
                if len(parts) != XYZ_FILE_PARTS_PER_LINE:
                    logger.warning(f"Invalid line in XYZ file: {line.strip()}")
                    continue

                symbol = parts[0]
                x, y, z = map(float, parts[1:])
                coords.append(BeadPosition(index=index, symbol=symbol, x=x, y=y, z=z))
    except Exception:
        logger.exception("Error reading XYZ file")
        raise
    return coords


def sanitize_for_json(obj: Any) -> Any:
    """
    Recursively sanitize an object to make it JSON serializable.

    Args:
        obj (Any): The object to sanitize.

    Returns:
        Any: A JSON-serializable representation of the input object.

    """
    seen: set[int] = set()

    def _inner(x: Any) -> Any:  # noqa: PLR0911, PLR0912
        obj_id = id(x)
        if obj_id in seen:
            return str(x)
        seen.add(obj_id)

        if dataclasses.is_dataclass(x) and not isinstance(x, type):
            x = dataclasses.asdict(x)

        if isinstance(x, np.ndarray):
            return x.tolist()
        if isinstance(x, np.integer):
            return int(x.item())
        if isinstance(x, np.floating):
            return float(x.item())
        if isinstance(x, np.bool_):
            return bool(x.item())
        if isinstance(x, (np.complexfloating, complex)):
            return {"real": float(x.real), "imag": float(x.imag)}

        if isinstance(x, Path):
            return str(x)

        if isinstance(x, Mapping):
            out: dict[str, Any] = {}
            for k, v in x.items():
                try:
                    key = str(k)
                except Exception:
                    key = repr(k)
                out[key] = _inner(v)
            return out

        if isinstance(x, Sequence) and not isinstance(x, (str, bytes, bytearray)):
            return [_inner(i) for i in x]

        if isinstance(x, set):
            return [_inner(i) for i in x]

        if hasattr(x, "__dict__"):
            try:
                return _inner(vars(x))
            except Exception:
                try:
                    return str(x)
                except Exception:
                    return repr(x)

        try:
            json.dumps(x)
        except TypeError:
            try:
                return str(x)
            except Exception:
                return repr(x)
        else:
            return x

    return _inner(obj)
