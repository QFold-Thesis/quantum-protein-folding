from __future__ import annotations

import dataclasses
import json
from collections.abc import Mapping, Sequence
from pathlib import Path
from typing import Any

import numpy as np

from constants import (
    XYZ_FILE_LINE_START_INDEX,
    XYZ_FILE_PARTS_PER_LINE,
    XYZ_FILENAME,
)
from logger import get_logger
from result.models import BeadPosition

logger = get_logger()

def create_xyz_file(coords: list[BeadPosition], dirpath: Path) -> Path:
    filepath: Path = dirpath / XYZ_FILENAME

    with filepath.open("w") as f:
        f.write(f"{len(coords)}\n")
        f.write("Generated by quantum-protein-folding\n")

        for bead_pos in coords:
            f.write(
                f"{bead_pos.symbol:<2} {bead_pos.x:>10.4f} {bead_pos.y:>10.4f} {bead_pos.z:>10.4f}\n"
            )

    return filepath


def read_xyz_file(filepath: Path) -> list[BeadPosition]:
    coords: list[BeadPosition] = []

    with filepath.open() as f:
        lines = f.readlines()
        num_atoms = int(lines[0].strip())

        for index, line in enumerate(
            lines[XYZ_FILE_LINE_START_INDEX : XYZ_FILE_LINE_START_INDEX + num_atoms]
        ):
            parts = line.split()
            if len(parts) != XYZ_FILE_PARTS_PER_LINE:
                logger.warning(f"Invalid line in XYZ file: {line.strip()}")
                continue

            symbol = parts[0]
            x, y, z = map(float, parts[1:])
            coords.append(BeadPosition(index=index, symbol=symbol, x=x, y=y, z=z))
    return coords


def sanitize_for_json(obj: Any) -> Any:
    seen: set[int] = set()

    def _inner(x: Any) -> Any:  # noqa: PLR0911, PLR0912
        obj_id = id(x)
        if obj_id in seen:
            return str(x)
        seen.add(obj_id)

        if dataclasses.is_dataclass(x) and not isinstance(x, type):
            x = dataclasses.asdict(x)

        if isinstance(x, np.ndarray):
            return x.tolist()
        if isinstance(x, np.integer):
            return int(x.item())
        if isinstance(x, np.floating):
            return float(x.item())
        if isinstance(x, np.bool_):
            return bool(x.item())
        if isinstance(x, (np.complexfloating, complex)):
            return {"real": float(x.real), "imag": float(x.imag)}

        if isinstance(x, Path):
            return str(x)

        if isinstance(x, Mapping):
            out: dict[str, Any] = {}
            for k, v in x.items():
                try:
                    key = str(k)
                except Exception:
                    key = repr(k)
                out[key] = _inner(v)
            return out

        if isinstance(x, Sequence) and not isinstance(x, (str, bytes, bytearray)):
            return [_inner(i) for i in x]

        if isinstance(x, set):
            return [_inner(i) for i in x]

        if hasattr(x, "__dict__"):
            try:
                return _inner(vars(x))
            except Exception:
                try:
                    return str(x)
                except Exception:
                    return repr(x)

        try:
            json.dumps(x)
        except TypeError:
            try:
                return str(x)
            except Exception:
                return repr(x)
        else:
            return x

    return _inner(obj)
