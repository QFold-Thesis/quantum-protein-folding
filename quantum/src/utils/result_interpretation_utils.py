from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING

import numpy as np

from constants import (
    CONFORMATION_ENCODING,
    DENSE_TURN_INDICATORS,
    OUTPUT_DATA_DIR,
    QUBITS_PER_TURN,
    SPARSE_TURN_INDICATORS,
    XYZ_FILE_LINE_START_INDEX,
    XYZ_FILE_PARTS_PER_LINE,
)
from enums import ConformationEncoding, TurnDirection
from exceptions import ConformationEncodingError
from logger import get_logger

if TYPE_CHECKING:
    from qiskit_algorithms import SamplingMinimumEigensolverResult

logger = get_logger()


@dataclass
class VQEOutput:
    bitstring: str
    probability: float
    state: str
    energy_value: np.complex128

    def __repr__(self) -> str:
        return (
            f"VQEOutput(bitstring={self.bitstring},\n"
            f"  probability={self.probability},\n"
            f"  state={self.state},\n"
            f"  energy_value={self.energy_value})"
        )

@dataclass
class BeadPosition:
    index: int
    symbol: str
    x: float
    y: float
    z: float

    @property
    def position(self) -> tuple[float, float, float]:
        return (self.x, self.y, self.z)


def interpret_raw_vqe_output(raw_output: SamplingMinimumEigensolverResult) -> VQEOutput:
    best_measurement = raw_output.best_measurement

    if not best_measurement:
        msg = "No best measurement found in VQE output."
        raise ValueError(msg)

    bitstring: str | None = best_measurement.get("bitstring")
    probability: float | None = best_measurement.get("probability")
    state: str | None = best_measurement.get("state")
    energy_value: np.complex128 | None = best_measurement.get("value")

    if None in (bitstring, probability, state, energy_value):
        msg = "Incomplete best measurement data in VQE output."
        raise ValueError(msg)

    return VQEOutput(
        bitstring=bitstring,
        probability=probability,
        state=state,
        energy_value=energy_value,
    )


def _preprocess_bitstring(
    bitstring: str, turn_encoding: dict[TurnDirection, str]
) -> str:
    """Preprocesses the bitstring by appending initial turns and reversing it."""
    return "".join(
        reversed(
            bitstring
            + turn_encoding[TurnDirection.DIR_1]
            + turn_encoding[TurnDirection.DIR_2]
        )
    )


def generate_coords_from_bitstring(bitstring: str, main_chain: str, side_chain: str) -> list[BeadPosition]:  # noqa: ARG001
    if CONFORMATION_ENCODING == ConformationEncoding.DENSE:
        turn_encoding = DENSE_TURN_INDICATORS
    elif CONFORMATION_ENCODING == ConformationEncoding.SPARSE:
        turn_encoding = SPARSE_TURN_INDICATORS
    else:
        raise ConformationEncodingError

    bitstring = _preprocess_bitstring(bitstring, turn_encoding)

    tetra_dirs = np.array(
        [[1, 1, 1], [1, -1, -1], [-1, 1, -1], [-1, -1, 1]], dtype=float
    )
    tetra_dirs /= np.linalg.norm(tetra_dirs[0])

    bitstring_to_direction = {
        bitstring: direction.value for direction, bitstring in turn_encoding.items()
    }

    turns_length = len(bitstring) // QUBITS_PER_TURN
    turns = [
        bitstring[i * QUBITS_PER_TURN : (i + 1) * QUBITS_PER_TURN]
        for i in range(turns_length)
    ]

    # initialize the starting position (first bead)
    current_pos = np.array([0.0, 0.0, 0.0])
    coords = [
        BeadPosition(
            index=0,
            symbol=main_chain[0],
            x=current_pos[0],
            y=current_pos[1],
            z=current_pos[2]
        )
    ]

    for turn, symbol in zip(turns, main_chain[1::]):
        if turn not in bitstring_to_direction:
            logger.warning(f"Unknown turn encoding: {turn}")
            continue
        direction_idx = bitstring_to_direction[turn]
        direction = tetra_dirs[direction_idx]
        current_pos = current_pos + direction
        coords.append(
            BeadPosition(
                index=len(coords),
                symbol=symbol,
                x=current_pos[0],
                y=current_pos[1],
                z=current_pos[2]
            )
        )

    return coords


def create_xyz_file(coords: list[BeadPosition], filepath: Path | None = None) -> Path:
    if filepath is None:
        timestamp = datetime.now(tz=timezone.utc).strftime("%Y%m%d_%H%M%S")

        symbol_sequence: str = "".join(bead_pos.symbol for bead_pos in coords)
        filename = f"{timestamp}-{symbol_sequence}.xyz"

        filepath = OUTPUT_DATA_DIR / filename
        filepath.touch(exist_ok=False)

    logger.debug(f"Saving coordinates to {filepath}")
    with filepath.open("w") as f:
        f.write(f"{len(coords)}\n")
        f.write("Generated by quantum-protein-folding\n")

        for bead_pos in coords:
            f.write(f"{bead_pos.symbol} {bead_pos.x:.4f} {bead_pos.y:.4f} {bead_pos.z:.4f}\n")

    return filepath


def read_xyz_file(filepath: Path) -> list[BeadPosition]:
    coords: list[BeadPosition] = []

    with filepath.open() as f:
        lines = f.readlines()
        num_atoms = int(lines[0].strip())

        for index, line in enumerate(lines[XYZ_FILE_LINE_START_INDEX : XYZ_FILE_LINE_START_INDEX + num_atoms]):
            parts = line.split()
            if len(parts) != XYZ_FILE_PARTS_PER_LINE:
                logger.warning(f"Invalid line in XYZ file: {line.strip()}")
                continue

            symbol = parts[0]
            x, y, z = map(float, parts[1:])
            coords.append(BeadPosition(index=index, symbol=symbol, x=x, y=y, z=z))
    return coords

